<!doctype html>
<html lang="en-us">
  <head>
    <title>My eBPF journey part 1: Using bpftrace to print packets // Rasek91&#39;s Blog</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.96.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Márton Rasek" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://rasek91.github.io/blog/css/main.min.81c4fa21837b24a3fbe7d9d59d93a4406540b4bad8793499162094e0d5a8f235.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="My eBPF journey part 1: Using bpftrace to print packets"/>
<meta name="twitter:description" content="As many of you probably know eBPF is a great technology which allows you to run code inside the Linux kernel. eBPF capabilities can be used best for observability, networking and security use cases. My goal is to test the networking aspect of eBPF.
As a first step I used bpftrace to make the start easier. My script prints IPv4 and IPv6 packets when received or sent. My intension is to develop more little programs and scripts around networking with eBPF and make them understand."/>

    <meta property="og:title" content="My eBPF journey part 1: Using bpftrace to print packets" />
<meta property="og:description" content="As many of you probably know eBPF is a great technology which allows you to run code inside the Linux kernel. eBPF capabilities can be used best for observability, networking and security use cases. My goal is to test the networking aspect of eBPF.
As a first step I used bpftrace to make the start easier. My script prints IPv4 and IPv6 packets when received or sent. My intension is to develop more little programs and scripts around networking with eBPF and make them understand." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://rasek91.github.io/blog/posts/ebpf_part1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-03T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-05-03T00:00:00+00:00" />



  </head>
  <body>
    <header class="app-header">
      <a href="https://rasek91.github.io/blog/"><img class="app-header-avatar" src="/blog/avatar.jpg" alt="Márton Rasek" /></a>
      <h1>Rasek91&#39;s Blog</h1>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/blog/">Home</a>
             - 
          
          <a class="app-header-menu-item" href="/blog/tags/">Tags</a>
      </nav>
      <p>Senior Software Engineer</p>
      <div class="app-header-social">
        
          <a href="https://github.com/Rasek91/" target="_blank" rel="noreferrer noopener">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>Github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg>
          </a>
        
          <a href="https://www.linkedin.com/in/m%C3%A1rton-rasek-4ab9aaba/" target="_blank" rel="noreferrer noopener">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-linkedin">
  <title>LinkedIn</title>
  <path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle>
</svg>
          </a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">My eBPF journey part 1: Using bpftrace to print packets</h1>
      <div class="post-meta">
        <div>
          Márton Rasek
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          May 3, 2022
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          11 min read
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>
</svg>
              <a class="tag" href="https://rasek91.github.io/blog/tags/ebpf/">ebpf</a>
              <a class="tag" href="https://rasek91.github.io/blog/tags/networking/">networking</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <p>As many of you probably know eBPF is a great technology which allows you to run code inside the Linux kernel.
eBPF capabilities can be used best for observability, networking and security use cases.
My goal is to test the networking aspect of eBPF.</p>
<p>As a first step I used <a href="https://github.com/iovisor/bpftrace">bpftrace</a> to make the start easier.
<a href="https://github.com/Rasek91/blog/tree/master/ebpf_part1/packets.bt">My script</a> prints IPv4 and IPv6 packets when received or sent.
My intension is to develop more little programs and scripts around networking with eBPF and make them understand.
If you want more details of the next post check out <a href="#next-steps">Next steps section</a>.</p>
<h2 id="brief-introduction-of-ebpf">Brief introduction of eBPF</h2>
<p>If you want more detailed description of eBPF I recommend you to check the following links: <a href="https://ebpf.io/">ebpf.io</a> and <a href="https://docs.cilium.io/en/latest/bpf/#bpf-guide">cilium bpf guide</a>.</p>
<p>Based on a very simple definition eBPF allows you to run code inside the Linux kernel in a save way without developing a kernel module.
eBPF programs are byte codes run as a virtual machine inside the kernel.
The code itself has been verified by the loader before running it to prevent crash inside the kernel.
Besides the advantage of the safety, eBPF programs compiled with Just-In-Time (JIT) compiler to run as efficient as possible.</p>
<p>eBPF programs have two part:</p>
<ol>
<li>the code running inside a safe virtual machine in the kernel and activate when the attached event happens, which can be either in the kernel or in the user space</li>
<li>the user space component to process the collected data</li>
</ol>
<p>There are special data types (eBPF maps) to communicate between these two components.</p>
<p>Fortunately you don&rsquo;t have to write eBPF byte code, but you can use a restricted version of C programming language to write your code running inside the kernel. For the user space component there are frameworks to load and use eBPF code in almost all of the popular programming languages.</p>
<h2 id="prerequisites">Prerequisites</h2>
<p>There are quite few prerequisites to run eBPF programs on your machine.
The most important one is that you need <strong>root</strong> privileges to load the program to your kernel.
This can be modified by settings which allow for any user to load eBPF programs, but I don&rsquo;t recommend to do that because I assume you don&rsquo;t want that someone else is able to customize your kernel.</p>
<p>Use at least a 4.9 version of Linux kernel and build with <a href="https://github.com/iovisor/bpftrace/blob/master/INSTALL.md#linux-kernel-requirements">specific options</a>.</p>
<h3 id="install-ebpf">Install eBPF</h3>
<p>Kernel headers should be available for eBPF. eBPF package name is differ for distribution, mine is <code>libbpf-dev</code>.
For more details check out the <a href="https://github.com/libbpf/libbpf">project&rsquo;s repository</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt-get install -y libbpf-dev linux-headers-<span style="color:#66d9ef">$(</span>uname -r<span style="color:#66d9ef">)</span>
</span></span></code></pre></div><h3 id="install-bpftool">Install bpftool</h3>
<p>BCC is a popular framework for working with eBPF.
It contains a bunch of useful tools for networking and tracing: <a href="https://github.com/iovisor/bcc/tree/master/examples">examples</a>.
<a href="https://github.com/iovisor/bcc/blob/master/INSTALL.md">Installation guide</a></p>
<p>bpftool is about manipulation of eBPF programs and maps.
You can generate BTF (BPF Type Format) which is the metadata format encoding the debug info related to BPF program/map.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt-get install -y bpfcc-tools bpftool
</span></span></code></pre></div><h3 id="install-bpftrace">Install bpftrace</h3>
<p>bpftrace is the easiest way to get started with eBPF.
It uses a C like scripting language format to develop programs.
Check out the <a href="https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md">language basics</a>.
<a href="https://github.com/iovisor/bpftrace/blob/master/INSTALL.md">Installation guide</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt-get install -y bpftrace
</span></span></code></pre></div><h3 id="check-commands">Check commands</h3>
<p>Try the commands below to check if your installation works properly.</p>
<p>The first command&rsquo;s output is the content of your kernel BTF file in a C header file format.
You should include this if you write standalone eBPF program, otherwise with bpftrace it is done automatically.</p>
<p>The second command lists all of the points where you can attach eBPF program to your kernel, arguments also listed for some of the <em>tracepoints</em> and <em>kfuncs</em>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo bpftool btf dump file /sys/kernel/btf/vmlinux format c
</span></span><span style="display:flex;"><span>sudo bpftrace -lv
</span></span></code></pre></div><h2 id="which-kprobe-and-tracepoint-should-i-use">Which <em>kprobe</em> and <em>tracepoint</em> should I use?</h2>
<p>In eBPF <em>kprobe</em> is for attaching a program to the beginning of a kernel function and its pair is <em>kretprobe</em>, which is for attaching in the end.
<em>tracepoint</em> is a Linux kernel capability and a program attached to one can react to many things like syscalls, socket, filesystem and etc. related events.</p>
<p>You can check the various available <em>tracepoints</em> in <code>/sys/kernel/debug/tracing/events</code> folder.
Every event has a format file which shows the available arguments in that <em>tracepoint</em> for example: <code>/sys/kernel/debug/tracing/events/timer/hrtimer_init/format</code>.</p>
<p>The kernel functions for sending and receiving packets contain <em>recv</em> or <em>send</em>.
In bpftrace you can check with a one-liner which attach points are used by a program.
This is a builtin variable and called <strong>probe</strong>.
I use a test user for sending and receiving packets so I can filter for that user id:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo bpftrace -e <span style="color:#e6db74">&#39;kprobe:*recv*,tracepoint:*recv* /uid == 1001/ {printf(&#34;%s\n&#34;, probe);}&#39;</span>
</span></span></code></pre></div><p>With this one-liner we can print all the receive related <em>kprobe</em> and <em>tracepoint</em> and later check them for arguments.</p>
<h3 id="test-tcp-connection">Test TCP connection</h3>
<p>For testing a TCP connection I use <code>curl</code> to send an HTTP request to <em><a href="https://www.google.com">www.google.com</a></em>.
I used the IP address of the server to not trigger a DNS request and a response during the test.</p>
<p>I start my one-liner in one window:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo bpftrace -e <span style="color:#e6db74">&#39;kprobe:*recv*,tracepoint:*recv* /uid == 1001/ {printf(&#34;%s\n&#34;, probe);}&#39;</span>
</span></span></code></pre></div><p>I send the request in a second one:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo -u test curl -4 -k --http1.1 http://172.217.19.110
</span></span></code></pre></div><p>The results:</p>
<pre tabindex="0"><code>❯ sudo bpftrace -e &#39;kprobe:*recv*,tracepoint:*recv* /uid == 1001/ {printf(&#34;%s\n&#34;, probe);}&#39; 
Attaching 141 probes...
tracepoint:syscalls:sys_enter_recvfrom
kprobe:__x64_sys_recvfrom
kprobe:__sys_recvfrom
kprobe:sock_recvmsg
kprobe:security_socket_recvmsg
kprobe:apparmor_socket_recvmsg
kprobe:inet_recvmsg
kprobe:tcp_recvmsg
kprobe:tcp_recvmsg_locked
kprobe:tcp_update_recv_tstamps
kprobe:tcp_recv_timestamp
tracepoint:syscalls:sys_exit_recvfrom
tracepoint:netvsc:nvsp_recv
kprobe:send_recv_completions
tracepoint:netvsc:nvsp_recv
kprobe:send_recv_completions
^C
</code></pre><h3 id="test-udp-connection">Test UDP connection</h3>
<p>For testing a UDP connection I use <code>nslookup</code> to send a DNS request to resolve <em><a href="https://www.google.com">www.google.com</a></em>.
I request A record type during the test so only one request will be sent to the DNS server.</p>
<p>I start my one-liner in one window:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo bpftrace -e <span style="color:#e6db74">&#39;kprobe:*recv*,tracepoint:*recv* /uid == 1001/ {printf(&#34;%s\n&#34;, probe);}&#39;</span>
</span></span></code></pre></div><p>I send the request in a second one:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo -u test nslookup -type<span style="color:#f92672">=</span>a www.google.com 8.8.8.8
</span></span></code></pre></div><p>The results:</p>
<pre tabindex="0"><code>❯ sudo bpftrace -e &#39;kprobe:*recv*,tracepoint:*recv* /uid == 1001/ {printf(&#34;%s\n&#34;, probe);}&#39;
Attaching 141 probes...
tracepoint:syscalls:sys_enter_recvmsg
kprobe:__x64_sys_recvmsg
kprobe:__sys_recvmsg
kprobe:___sys_recvmsg
kprobe:____sys_recvmsg
kprobe:sock_recvmsg
kprobe:security_socket_recvmsg
kprobe:apparmor_socket_recvmsg
kprobe:inet_recvmsg
kprobe:udp_recvmsg
kprobe:__skb_recv_udp
kprobe:__skb_try_recv_from_queue
kprobe:__skb_try_recv_from_queue
tracepoint:syscalls:sys_exit_recvmsg
^C
</code></pre><h3 id="test-tls-connection">Test TLS connection</h3>
<p>For testing a TLS connection I use <code>curl</code> to send an HTTPS request to <em><a href="https://www.google.com">www.google.com</a></em>.
I used the IP address of the server to not trigger a DNS request and a response during the test.</p>
<p>I start my one-liner in one window:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo bpftrace -e <span style="color:#e6db74">&#39;kprobe:*recv*,tracepoint:*recv* /uid == 1001/ {printf(&#34;%s\n&#34;, probe);}&#39;</span>
</span></span></code></pre></div><p>I send the request in a second one:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo -u test curl -4 -k --http1.1 https://172.217.19.110
</span></span></code></pre></div><p>The results:</p>
<pre tabindex="0"><code>❯ sudo bpftrace -e &#39;kprobe:*recv*,tracepoint:*recv* /uid == 1001/ {printf(&#34;%s\n&#34;, probe);}&#39; 
Attaching 141 probes...
kprobe:sock_recvmsg
kprobe:security_socket_recvmsg
kprobe:apparmor_socket_recvmsg
kprobe:inet_recvmsg
kprobe:tcp_recvmsg
kprobe:tcp_recvmsg_locked
^C
</code></pre><p>The <code>recv* tracepoints</code> are not used during the TLS connection.
But how the packets have been arrived and get processed then?</p>
<p><code>libssl</code> library and some other implementations like <code>nc</code> use another low level kernel function to receive and send packets.
These are <code>syscall read</code> and <code>syscall write</code>.</p>
<p>The new results:</p>
<pre tabindex="0"><code>❯ sudo bpftrace -e &#39;kprobe:*recv*,tracepoint:*recv*,tracepoint:syscalls:sys_e*_read /uid == 1001/ {printf(&#34;%s\n&#34;, probe);}&#39;
Attaching 143 probes...
tracepoint:syscalls:sys_enter_read
kprobe:sock_recvmsg
kprobe:security_socket_recvmsg
kprobe:apparmor_socket_recvmsg
kprobe:inet_recvmsg
kprobe:tcp_recvmsg
kprobe:tcp_recvmsg_locked
kprobe:tcp_update_recv_tstamps
kprobe:tcp_recv_timestamp
tracepoint:syscalls:sys_exit_read
^C
</code></pre><h3 id="analyzing-the-results">Analyzing the results</h3>
<p>Both TCP and UDP receive start with a <code>syscall recv* tracepoint</code>.
The first common point in the execution is <code>kprobe:sock_recvmsg</code>.
TLS receive starts with <code>syscall read tracepoint</code> and executes <code>kprobe:sock_recvmsg</code>.
These functions are a good starting point to build a script printing the messages out.</p>
<p>There are a couple of more <code>syscall recv* tracepoints</code> which can be used to receive the messages.
We can list them by using bpftrace with the corresponding arguments:</p>
<pre tabindex="0"><code>❯ sudo bpftrace -lv &#39;tracepoint:syscalls:sys_enter_recv*,tracepoint:syscalls:sys_enter_read&#39;
tracepoint:syscalls:sys_enter_recvfrom
    int __syscall_nr
    int fd
    void * ubuf
    size_t size
    unsigned int flags
    struct sockaddr * addr
    int * addr_len
tracepoint:syscalls:sys_enter_recvmmsg
    int __syscall_nr
    int fd
    struct mmsghdr * mmsg
    unsigned int vlen
    unsigned int flags
    struct __kernel_timespec * timeout
tracepoint:syscalls:sys_enter_recvmsg
    int __syscall_nr
    int fd
    struct user_msghdr * msg
    unsigned int flags
tracepoint:syscalls:sys_enter_read
    int __syscall_nr
    unsigned int fd
    char * buf
    size_t count
</code></pre><p>The arguments are for storing the messages such as:</p>
<ul>
<li><code>tracepoint:syscalls:sys_enter_recvfrom</code>: <code>void * ubuf</code></li>
<li><code>tracepoint:syscalls:sys_enter_recvmmsg</code>: <code>struct mmsghdr * mmsg</code></li>
<li><code>tracepoint:syscalls:sys_enter_recvmsg</code>: <code>struct user_msghdr * msg</code></li>
<li><code>tracepoint:syscalls:sys_enter_read</code>: <code>char * buf</code></li>
</ul>
<p>The same goes for the sending functions:</p>
<pre tabindex="0"><code>❯ sudo bpftrace -lv &#39;tracepoint:syscalls:sys_enter_send*,tracepoint:syscalls:sys_enter_write&#39;
tracepoint:syscalls:sys_enter_sendfile64
    int __syscall_nr
    int out_fd
    int in_fd
    loff_t * offset
    size_t count
tracepoint:syscalls:sys_enter_sendmmsg
    int __syscall_nr
    int fd
    struct mmsghdr * mmsg
    unsigned int vlen
    unsigned int flags
tracepoint:syscalls:sys_enter_sendmsg
    int __syscall_nr
    int fd
    struct user_msghdr * msg
    unsigned int flags
tracepoint:syscalls:sys_enter_sendto
    int __syscall_nr
    int fd
    void * buff
    size_t len
    unsigned int flags
    struct sockaddr * addr
    int addr_len
tracepoint:syscalls:sys_enter_write
    int __syscall_nr
    unsigned int fd
    const char * buf
    size_t count
</code></pre><p>The <em>sendfile64</em> function is used to copy data between file descriptors.</p>
<p>These <em>tracepoints</em> are a great way to save the content of the message but they work on file descriptors and not with sockets.
So IP addresses and port numbers are not visible in here.</p>
<p>Fortunately the first common execution point <code>kprobe:sock_recvmsg</code> uses socket as first argument.
bpftrace can&rsquo;t show the arguments of a <em>kprobe</em> but a short googling can help us finding the details of the function: <code>int sock_recvmsg(struct socket *sock, struct msghdr *msg, int flags)</code> <a href="https://elixir.bootlin.com/linux/latest/source/net/socket.c#L962">link</a>.</p>
<p>The second argument is the message represented in the kernel but when I print it either in entry or exit point, it always shows a bunch of zeros or garbage.
That&rsquo;s the reason why I choose to use the <em>tracepoints</em> to save the content of the actual message.</p>
<h2 id="script-review">Script review</h2>
<p>After the introduction of eBPF and explaining my decisions on designing this script I want to show you the actual code piece by piece and explain it in a more detailed way.
You can download the script in raw format from <a href="https://raw.githubusercontent.com/Rasek91/blog/master/ebpf_part1/packets.bt">here</a> or check the <a href="https://github.com/Rasek91/blog/tree/master/ebpf_part1">repository</a>.</p>
<h3 id="setup-and-teardown">Setup and teardown</h3>
<p>bpftrace has two special attach points: <strong>BEGIN</strong>, <strong>END</strong>.
<strong>BEGIN</strong> is triggered before every other probes.
I use it to print information about the script at start.
<strong>END</strong> is triggered after every other probes have been detached.
I use it to delete all the eBPF maps created by the script.</p>
<h3 id="get-socket-details">Get socket details</h3>
<p>Both <code>kprobe:sock_sendmsg</code> and <code>kprobe:sock_recvmsg</code> functions&rsquo; first argument is the socket in use.
So one function can be attached to both probes.
The socket&rsquo;s type is the so called <code>struct socket</code> which contains all the information I want to print:</p>
<ul>
<li>IP version number</li>
<li>source and destination IPv4/IPv6 addresses</li>
<li>IP protocol number</li>
<li>source and destination TCP/UDP port numbers</li>
</ul>
<p><code>struct socket</code> has an attribute <em>sk</em> of which type is <code>struct sock</code>.
It is the network socket representation with all the network details.</p>
<p><code>struct sock</code> attributes to save:</p>
<ul>
<li>IP version number: <code>$socket-&gt;sk-&gt;__sk_common.skc_family</code></li>
<li>source IPv4 addresses: <code>$socket-&gt;sk-&gt;__sk_common.skc_rcv_saddr</code></li>
<li>source IPv6 addresses: <code>$socket-&gt;sk-&gt;__sk_common.skc_v6_rcv_saddr.in6_u.u6_addr8</code></li>
<li>destination IPv4 addresses: <code>$socket-&gt;sk-&gt;__sk_common.skc_daddr</code></li>
<li>destination IPv6 addresses: <code>$socket-&gt;sk-&gt;__sk_common.skc_v6_daddr.in6_u.u6_addr8</code></li>
<li>IP protocol number: <code>$socket-&gt;sk-&gt;sk_type</code></li>
<li>source TCP/UDP port numbers: <code>$socket-&gt;sk-&gt;__sk_common.skc_num</code></li>
<li>destination TCP/UDP port numbers: <code>$socket-&gt;sk-&gt;__sk_common.skc_dport</code></li>
</ul>
<p>bpftrace <a href="https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md#14-ntop-convert-ip-address-data-to-text">ntop</a> function can convert both IPv4 and IPv6 addresses to human readable format.
The destination port is automatically in big endian format so I have to convert it to little endian.</p>
<p>If you want to read more about <a href="https://elixir.bootlin.com/linux/latest/source/include/linux/net.h#L114">struct socket</a> and <a href="https://elixir.bootlin.com/linux/latest/source/include/net/sock.h#L355">struct sock</a>.
There is also a list of <a href="https://www.kernel.org/doc/htmldocs/networking/API-struct-sock.html">sock attributes</a>.</p>
<h3 id="get-message-content">Get message content</h3>
<p>The attach points for saving the message content have various arguments for receiving and sending so it needs different eBPF maps because I use the process id as a key.
This way the receiving function can overwrite the sending function message location if both use the same map.</p>
<p>The message buffer arguments to save:</p>
<ul>
<li><code>tracepoint:syscalls:sys_enter_sendto</code>: <code>args-&gt;buff</code></li>
<li><code>tracepoint:syscalls:sys_enter_recvfrom</code>: <code>ubuf</code></li>
<li><code>tracepoint:syscalls:sys_enter_sendmsg,tracepoint:syscalls:sys_enter_recvmsg</code>: <code>args-&gt;msg</code></li>
<li><code>tracepoint:syscalls:sys_enter_sendmmsg,tracepoint:syscalls:sys_enter_recvmmsg</code>: <code>args-&gt;mmsg</code></li>
<li><code>tracepoint:syscalls:sys_enter_write,tracepoint:syscalls:sys_enter_read</code>: <code>args-&gt;buf</code></li>
</ul>
<p>The <em>mmsg</em> functions have different message format so it is incompatible with the other four types.
Therefore we need to create a new map.</p>
<h3 id="print-everything">Print everything</h3>
<p>In the <code>tracepoint:syscalls:sys_enter*</code> the buffer contains garbage because the message content is copied to the buffer only after the execution of the function.
The <code>tracepoint:syscalls:sys_exit*</code> only argument is the return value of the function, that is the reason why the location of the buffer is saved at entry points.
I print everything in one function so they will be in the right order.</p>
<p>bpftrace can only print maximum 64 characters of a string. If you add the <em>BPFTRACE_STRLEN</em> environment variable, it can extend the maximum to 200.
The <a href="https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md#21-buf-buffers">buf</a> function uses the same <strong>BPFTRACE_STRLEN</strong> environment variable to print data in hex-formatted string.
This way only 200 characters from a message can be printed.
The length of the message is the return value of <em>msg</em> and <em>to</em>, <em>from</em> functions.
The <em>mmsg</em> function does not return with the message length but the message buffer contains its length in: <code>@msend[pid]-&gt;msg_hdr.msg_iov-&gt;iov_len</code>.</p>
<p>The builtin <em>pid</em>, <em>uid</em> and <em>comm</em> variables are available by default in bpftrace.</p>
<p>I changed the filter for the exit points to trigger only if the socket type is IPv4 or IPv6 and is saved to <em>@ip_version[pid]</em> eBPF map.
The entry points are triggered before the <code>kprobe:sock_*</code> based on the <a href="#test-tcp-connection">tests</a> so in that call the maps saved in <code>kprobe:sock_*</code> are not available yet.</p>
<h2 id="limitations-of-the-script">Limitations of the script</h2>
<p>The encrypted packets are not decrypted at this point of the execution.
The content is not readable.
Also TLS control messages are printed out and not just the actual data from the application.
See <a href="#curl-tls">curl TLS section</a> and <a href="#pion-dtls">Pion DTLS section</a>.</p>
<h2 id="demo">Demo</h2>
<p>I record some examples:</p>
<h3 id="curl">curl</h3>
<p><img src="curl.gif" alt="curl"></p>
<h3 id="nc-using-tcp">nc using TCP</h3>
<p><img src="nc_tcp.gif" alt="nc_tcp"></p>
<h3 id="curl-tls">curl TLS</h3>
<p><img src="curl_tls.gif" alt="curl_tls"></p>
<h3 id="nslookup">nslookup</h3>
<p><img src="nslookup.gif" alt="nslookup"></p>
<h3 id="nc-using-udp">nc using UDP</h3>
<p><img src="nc_udp.gif" alt="nc_udp"></p>
<h3 id="pion-dtls">Pion DTLS</h3>
<p><img src="dtls.gif" alt="dtls"></p>
<h2 id="next-steps">Next steps</h2>
<p>My plan is to write a program similar to this one, but using <a href="https://github.com/cilium/ebpf">Cilium eBPF</a>.
I also want to dig a little bit deeper into the Linux kernel packet handling and find an attach point where the packets are not fully processed yet.
I saw a great presentation about <a href="https://www.youtube.com/watch?v=vqx-hLYfCYE">PWRE</a> and they were talking about <code>struct skb</code>.
This struct is for representing every packet that the kernel receives or sends.
So I want a program which uses an attach point with <code>struct skb</code>, processes the packets and prints the details of them.</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
